Stack: Node js, Express js, PostgreSQL, Sequelize ORM, Typescript
Project folder structure:
/src
 -config - database.ts
 -controllers - authController.ts, userController.ts, publicationController.ts, commentController.ts, galleryController.ts, higgsfieldController.ts, klingController.ts
 -lib - utils.ts
 -middleware - auth.ts, upload.ts
 -models - associations.ts, User.ts, Publications.ts, Subscriptions.ts, LikedPublication.ts, Comment.ts, LikedComment.ts, Gallery.ts
 -routes - auth.ts, user.ts, publication.ts, gallery.ts, comment.ts, higgsfield.ts, kling.ts
 -services - authService.ts, emailService.ts, passwordService.ts, higgsfieldService.ts, klingService.ts
 -index.ts
/public
/private
.env

-----------------------------------------------------------------------------------config
import dotenv from 'dotenv'; 
import { Sequelize } from 'sequelize';

dotenv.config()

export const db = new Sequelize(
  process.env.DB_NAME,
  process.env.DB_USER,
  process.env.DB_PASSWORD, {
  host: process.env.DB_HOST,
  dialect: 'postgres',
  logging: false,
});

try {
  db.authenticate();
  console.log('Connection has been established successfully.');
} catch (error) {
  console.error('Unable to connect to the database:', error);
}

export default db;

-----------------------------------------------------------------------------------lib
import express from "express";

import { User } from "../models/User";
import { Comment } from "../models/Comment";

// Helper to manage daily actions and award tokens
export const handleUserAction = async (user: User, tokenAmount: number) => {
    const now = new Date();
    const lastReset = new Date(user.dailyActions.lastReset);

    // Reset daily action count if it's a new day
    if (now.toDateString() !== lastReset.toDateString()) {
        user.dailyActions = { count: 0, lastReset: now };
    }

    if (user.dailyActions.count < 10) {
        user.tokens += tokenAmount;
        user.dailyActions.count += 1;
        await user.save();
    }
};

// Helper to wrap async route handlers
export const asyncHandler = (fn: any) => (req: express.Request, res: express.Response, next: express.NextFunction) => {
    Promise.resolve(fn(req, res, next)).catch(next);
};

// Helper function to recursively fetch replies
export const fetchReplies = async (comment: Comment) => {
    const replies = await Comment.findAll({
        where: { parentId: comment.id },
        include: [{ model: User, as: 'author', attributes: ['id', 'username', 'fullname', 'avatar'] }],
        order: [['createdAt', 'ASC']]
    });

    for (const reply of replies) {
        (reply as any).dataValues.replies = await fetchReplies(reply);
    }
    return replies;
};


-----------------------------------------------------------------------------------middleware
-----------------------------------------------------------------------------------auth
import { User } from '../models/User';
import { verifyToken } from '../services/authService';
import { Request, Response, NextFunction } from 'express';

// Extending Express Request type to include user
declare global {
    namespace Express {
        interface Request {
            user?: any;
        } 
    }
}

export const auth = async (req: Request, res: Response, next: NextFunction): Promise<void> => {
    try {
        const token = req.cookies.token || req.header('Authorization')?.replace('Bearer ', '');

        if (!token) {
            res.status(401).json({ message: 'Authentication required' });
            return;
        }

        const decoded = verifyToken(token);
        if (!decoded) {
            res.status(401).json({ message: 'Invalid token' });
            return;
        }

        const user = await User.findByPk(decoded.id);
        if (!user) {
            res.status(404).json({ message: 'User not found' });
            return;
        }

        req.user = user;
        next();
    } catch (error) {
        console.error('Auth middleware error:', error);
        res.status(401).json({ message: 'Authentication failed' });
    }
};

-----------------------------------------------------------------------------------Upload
import fs from 'fs';
import path from 'path';
import multer from 'multer';

import { Request } from 'express';

// Define the destination directory for avatars
const avatarDir = path.join(__dirname, '../../public/users/avatars');

// Ensure the directory exists
if (!fs.existsSync(avatarDir)) {
    fs.mkdirSync(avatarDir, { recursive: true });
}

// Configure multer storage
const storage = multer.diskStorage({
    destination: (req, file, cb) => {
        cb(null, avatarDir);
    },
    filename: (req: Request, file, cb) => {
        // Create a unique filename to prevent overwrites
        // format: userId-timestamp.extension
        const userId = req.user.id;
        const uniqueSuffix = Date.now() + '-' + Math.round(Math.random() * 1E9);
        const extension = path.extname(file.originalname);
        cb(null, `${userId}-${uniqueSuffix}${extension}`);
    }
});

// File filter to only accept image files
const fileFilter = (req: Request, file: Express.Multer.File, cb: multer.FileFilterCallback) => {
    const allowedTypes = /jpeg|jpg|png|gif/;
    const mimetype = allowedTypes.test(file.mimetype);
    const extname = allowedTypes.test(path.extname(file.originalname).toLowerCase());

    if (mimetype && extname) {
        return cb(null, true);
    }
    cb(new Error('Error: File upload only supports the following filetypes - ' + allowedTypes));
};

// Initialize multer with the storage and file filter configurations
export const uploadAvatar = multer({
    storage: storage,
    limits: { fileSize: 2 * 1024 * 1024 }, // Limit file size to 2MB
    fileFilter: fileFilter
}).single('avatar'); // 'avatar' is the name of the form field

// Helper function to upload media
const imageAndVideoFileFilter = (req: Request, file: Express.Multer.File, cb: multer.FileFilterCallback) => {
    const allowedImageTypes = /jpeg|jpg|png|gif/;
    const allowedVideoTypes = /mp4|mov|avi|webm|mkv/;
    const ext = path.extname(file.originalname).toLowerCase().replace('.', '');
    const mimetype = file.mimetype;

    if (
        allowedImageTypes.test(ext) ||
        allowedVideoTypes.test(ext) ||
        mimetype.startsWith('image/') ||
        mimetype.startsWith('video/')
    ) {
        return cb(null, true);
    }
    cb(new Error('Error: File upload only supports image and video filetypes - jpeg, jpg, png, gif, mp4, mov, avi, webm, mkv'));
};

// Обновленный uploadPublicationImage
export const uploadPublicationImage = multer({
    storage: multer.diskStorage({
        destination: (req, file, cb) => {
            const publicationDir = path.join(__dirname, '../../public/publications');
            if (!fs.existsSync(publicationDir)) { fs.mkdirSync(publicationDir, { recursive: true }); }
            cb(null, publicationDir);
        },
        filename: (req: Request, file, cb) => {
            const userId = req.user.id;
            const uniqueSuffix = Date.now() + '-' + Math.round(Math.random() * 1E9);
            const extension = path.extname(file.originalname);
            cb(null, `${userId}-${uniqueSuffix}${extension}`);
        }
    }),
    limits: { fileSize: 200 * 1024 * 1024 }, // 200MB limit для видео
    fileFilter: imageAndVideoFileFilter
}).single('publicationMedia'); // Можно переименовать поле, если хотите


const privateDir = path.join(__dirname, '../../private/user_uploads');
if (!fs.existsSync(privateDir)) {
    fs.mkdirSync(privateDir, { recursive: true });
}

// --- New: Configure multer for private image uploads for AI generation ---
export const uploadPrivateImage = multer({
    storage: multer.diskStorage({
        destination: (req, file, cb) => {
            cb(null, privateDir);
        },
        filename: (req, file, cb) => {
            const userId = req.user.id;
            const uniqueSuffix = Date.now() + '-' + Math.round(Math.random() * 1E9);
            const extension = path.extname(file.originalname);
            cb(null, `private-${userId}-${uniqueSuffix}${extension}`);
        }
    }),
    limits: { fileSize: 200 * 1024 * 1024 }, // 200MB limit
    fileFilter: imageAndVideoFileFilter // You can reuse the existing image fileFilter
}).single('privateMedia');



-----------------------------------------------------------------------------------services
auth
import dotenv from 'dotenv';
import jwt from 'jsonwebtoken';

dotenv.config();

// Configs
const JWT_EXPIRES_IN = '365d';
const JWT_SECRET = process.env.JWT_SECRET;

// Generate token
export const generateToken = (userId: string): string => {
  return jwt.sign({ id: userId }, JWT_SECRET, {
    expiresIn: JWT_EXPIRES_IN,
  });
};

// Verify token
export const verifyToken = (token: string): { id: string } | null => {
  try {
    return jwt.verify(token, JWT_SECRET) as { id: string };
  } catch (error) {
    return null;
  }
};

-----------------------------------------------------------------------------------email
import dotenv from 'dotenv';
import nodemailer from 'nodemailer';

dotenv.config();

// Reusable transporter object using credentials from .env
const transporter = nodemailer.createTransport({
    host: process.env.EMAIL_HOST,
    port: parseInt(process.env.EMAIL_PORT || '587', 10),
    secure: process.env.EMAIL_PORT === '465', // true for 465, false for other ports
    auth: {
        user: process.env.EMAIL_USER,
        pass: process.env.EMAIL_PASS,
    },
});

// --- Send Verification OTP Email ---
export const sendVerificationEmail = async (to: string, otp: string) => {
    const mailOptions = {
        from: 'Volshebny no-reply',
        to,
        subject: 'Email Verification',
        html: `
        <div style="font-family: Arial, sans-serif; background: #f6f8fb; padding: 32px;">
            <div style="max-width: 480px; margin: 0 auto; background: #fff; border-radius: 10px; box-shadow: 0 2px 8px rgba(0,0,0,0.07); padding: 32px;">
                <h2 style="color: #3a3a3a; margin-bottom: 16px;">Email Verification</h2>
                <p style="color: #444; font-size: 16px; margin-bottom: 24px;">
                    Your verification code is below. It will expire in 10 minutes.
                </p>
                <div style="display: flex; align-items: center; justify-content: center; height: 4rem; background: oklch(87% 0 0); margin-bottom: 24px;">
                    <span style="font-weight: 800; letter-spacing: 2px; font-size: 20px;">${otp}</span>
                </div>
                <hr style="border: none; border-top: 1px solid #eee; margin: 32px 0;">
                <p style="color: #bbb; font-size: 12px; text-align: center;">
                    &copy; ${new Date().getFullYear()} Volshebny bot. All rights reserved.
                </p>
            </div>
        </div>
        `,
    };

    try {
        await transporter.sendMail(mailOptions);
        console.log('Verification email sent to', to);
    } catch (error) {
        console.error('Error sending verification email:', error);
    }
};

// --- Send Password Reset Email ---
export const sendPasswordResetEmail = async (to: string, token: string) => {
    const resetUrl = `http://localhost:3000/reset-password/${token}`;

    const mailOptions = {
        from: 'Volshebny no-reply',
        to,
        subject: 'Password Reset Request',
        html: `
        <div style="font-family: Arial, sans-serif; background: #f6f8fb; padding: 32px;">
            <div style="max-width: 480px; margin: 0 auto; background: #fff; border-radius: 10px; box-shadow: 0 2px 8px rgba(0,0,0,0.07); padding: 32px;">
                <h2 style="color: #3a3a3a; margin-bottom: 16px;">Password Reset Request</h2>
                <p style="color: #444; font-size: 16px; margin-bottom: 24px;">
                    We received a request to reset your password. Click the button below to set a new password. If you did not request this, you can safely ignore this email.
                </p>
                <a href="${resetUrl}" 
                   style="display: inline-block; padding: 14px 32px; background: linear-gradient(90deg, #6a5af9 0%, #7b8cff 100%); color: #fff; font-weight: bold; border-radius: 6px; text-decoration: none; font-size: 16px; margin-bottom: 24px;">
                    Reset Password
                </a>
                <p style="color: #888; font-size: 13px; margin-top: 32px;">
                    If the button above does not work, copy and paste this link into your browser:<br>
                    <span style="color: #6a5af9;">${resetUrl}</span>
                </p>
                <hr style="border: none; border-top: 1px solid #eee; margin: 32px 0;">
                <p style="color: #bbb; font-size: 12px; text-align: center;">
                    &copy; ${new Date().getFullYear()} Volshebny bot. All rights reserved.
                </p>
            </div>
        </div>
        `,
    };

    try {
        await transporter.sendMail(mailOptions);
        console.log('Password reset email sent to', to);
    } catch (error) {
        console.error('Error sending password reset email:', error);
    }
};

-----------------------------------------------------------------------------------password
import crypto from 'crypto';
import bcrypt from 'bcrypt';

import { User } from '../models/User';
import { sendPasswordResetEmail } from './emailService';

export const createPasswordResetToken = async (user: User): Promise<string> => {
    const resetToken = crypto.randomBytes(32).toString('hex');

    user.passwordResetToken = await bcrypt.hash(resetToken, 10);
    user.passwordResetTokenExpires = new Date(Date.now() + 10 * 60 * 1000); // 10 minutes

    await user.save();
    return resetToken;
};

export const handleForgotPassword = async (email: string) => {
    const user = await User.findOne({ where: { email, verified: true } });
    
    if (!user) {
        // Don't reveal that the user doesn't exist
        console.log("Password reset requested for non-existent or unverified email.");
        return;
    }

    const resetToken = await createPasswordResetToken(user);
    await sendPasswordResetEmail(user.email, resetToken);
};

-----------------------------------------------------------------------------------higgsfield
import axios from 'axios';
import path from 'path';
import fs from 'fs';
import { v4 as uuidv4 } from 'uuid';

const HIGGSFIELD_API_URL = 'https://api.unifically.com/higgsfield';
const HIGGSFIELD_API_KEY = process.env.HIGGSFIELD_API;

// --- THIS IS THE CHANGE ---
// The function now accepts imageUrls and sends a JSON payload.
export const generateVideo = async (apiPayload: any, imageUrls: string[]) => {
    // Combine the API payload with the image URLs
    const requestBody = {
        ...apiPayload,
        image: imageUrls, // Add the array of public image URLs
        model: "standard" // Add model, as seen in the docs
    };

    try {
        const response = await axios.post(`${HIGGSFIELD_API_URL}/generate`, requestBody, {
            headers: {
                'Content-Type': 'application/json', // Set the correct header for a JSON request
                'Authorization': `Bearer ${HIGGSFIELD_API_KEY}`,
            },
        });
        return response.data;
    } catch (error) {
        // The error log will now show the exact JSON body that was rejected
        console.error('Error generating video:', error.response?.data || error.message);
        throw new Error('Failed to start video generation.');
    }
};
// --- END OF CHANGE ---


// The other functions remain the same.
export const getVideo = async (taskId: string) => {
    try {
        const response = await axios.get(`${HIGGSFIELD_API_URL}/feed/${taskId}`, {
            headers: {
                'Authorization': `Bearer ${HIGGSFIELD_API_KEY}`,
            },
        });
        return response.data;
    } catch (error) {
        console.error('Error getting video status:', error.response?.data || error.message);
        throw new Error('Failed to get video generation status.');
    }
};

export const downloadVideo = async (videoUrl: string): Promise<string> => {
    const videoDir = path.join(__dirname, '../../public/videos');
    if (!fs.existsSync(videoDir)) {
        fs.mkdirSync(videoDir, { recursive: true });
    }
    const filename = `${uuidv4()}.mp4`;
    const outputPath = path.join(videoDir, filename);

    try {
        const response = await axios({
            method: 'GET',
            url: videoUrl,
            responseType: 'stream',
        });

        const writer = fs.createWriteStream(outputPath);
        response.data.pipe(writer);

        return new Promise((resolve, reject) => {
            writer.on('finish', () => resolve(`/videos/${filename}`));
            writer.on('error', reject);
        });
    } catch (error) {
        console.error('Error downloading video:', error);
        throw new Error('Failed to download video.');
    }
};

-----------------------------------------------------------------------------------models
-----------------------------------------------------------------------------------User
import bcrypt from 'bcrypt';
import db from '../config/database';
import type { Comment } from './Comment';
import type { Publication } from './Publication';
import {
    Model,
    DataTypes,
    HasManyGetAssociationsMixin,
    BelongsToManyAddAssociationMixin,
    BelongsToManyRemoveAssociationMixin,
    BelongsToManyGetAssociationsMixin
} from 'sequelize';

// --- User Model Attributes ---
export interface UserAttributes {
    id: string;
    fullname?: string;
    username?: string;
    email: string;
    bio?: string;
    password?: string;
    avatar?: string;
    interests?: string[];
    tokens: number;
    dailyActions: {
        count: number;
        lastReset: Date;
    };
    verified: boolean;
    otp?: string;
    otpExpires?: Date;
    passwordResetToken?: string;
    passwordResetTokenExpires?: Date;
    createdAt?: Date;
    updatedAt?: Date;
}

// --- User Model Class ---
export class User extends Model<UserAttributes> implements UserAttributes {
    public id!: string;
    public fullname!: string;
    public username!: string;
    public email!: string;
    public bio?: string;
    public password!: string;
    public avatar?: string;
    public interests?: string[];
    public tokens!: number;
    public dailyActions!: {
        count: number;
        lastReset: Date;
    };
    public verified!: boolean;
    public otp?: string;
    public otpExpires?: Date;
    public passwordResetToken?: string;
    public passwordResetTokenExpires?: Date;

    // Timestamps
    public readonly createdAt!: Date;
    public readonly updatedAt!: Date;

    public async comparePassword(candidatePassword: string): Promise<boolean> {
        if (!this.password) return false;
        return bcrypt.compare(candidatePassword, this.password);
    }

    // --- Sequelize Mixins for Associations ---
    public getPublications!: HasManyGetAssociationsMixin<Publication>;

    // Following/Followers
    public getFollowing!: BelongsToManyGetAssociationsMixin<User>;
    public addFollowing!: BelongsToManyAddAssociationMixin<User, string>;
    public removeFollowing!: BelongsToManyRemoveAssociationMixin<User, string>;
    public getFollowers!: BelongsToManyGetAssociationsMixin<User>;

    // Liked Publications
    public getLikedPublications!: BelongsToManyGetAssociationsMixin<Publication>;
    public addLikedPublication!: BelongsToManyAddAssociationMixin<Publication, string>;
    public removeLikedPublication!: BelongsToManyRemoveAssociationMixin<Publication, string>;

    // Liked Comments
    public getLikedComments!: BelongsToManyGetAssociationsMixin<Comment>;
    public addLikedComment!: BelongsToManyAddAssociationMixin<Comment, string>;
    public removeLikedComment!: BelongsToManyRemoveAssociationMixin<Comment, string>;
}

// --- Initialize User Model ---
User.init(
    {
        id: {
            type: DataTypes.UUID,
            defaultValue: DataTypes.UUIDV4,
            primaryKey: true,
        },
        fullname: {
            type: DataTypes.STRING(32),
            allowNull: true,
        },
        username: {
            type: DataTypes.STRING(16),
            allowNull: true,
            unique: true,
        },
        email: {
            type: DataTypes.STRING(50),
            allowNull: false,
            unique: true,
            validate: { isEmail: true },
        },
        bio: {
            type: DataTypes.STRING(72),
            allowNull: true,
        },
        password: {
            type: DataTypes.STRING(60),
            allowNull: true,
        },
        avatar: {
            type: DataTypes.STRING,
            allowNull: true,
        },
        interests: {
            type: DataTypes.ARRAY(DataTypes.STRING),
            allowNull: true,
            defaultValue: [],
        },
        tokens: {
            type: DataTypes.INTEGER,
            allowNull: false,
            defaultValue: 500,
        },
        dailyActions: {
            type: DataTypes.JSONB,
            allowNull: false,
            defaultValue: { count: 0, lastReset: new Date() },
        },
        verified: {
            type: DataTypes.BOOLEAN,
            defaultValue: false,
            allowNull: false,
        },
        otp: {
            type: DataTypes.STRING,
            allowNull: true,
        },
        otpExpires: {
            type: DataTypes.DATE,
            allowNull: true,
        },
        passwordResetToken: {
            type: DataTypes.STRING,
            allowNull: true,
        },
        passwordResetTokenExpires: {
            type: DataTypes.DATE,
            allowNull: true,
        }
    },
    {
        sequelize: db,
        modelName: 'User',
        tableName: 'users',
        hooks: {
            beforeCreate: async (user: User) => {
                if (user.password) {
                    const salt = await bcrypt.genSalt(10);
                    user.password = await bcrypt.hash(user.password, salt);
                }
            },
            beforeUpdate: async (user: User) => {
                if (user.changed('password') && user.password) {
                    const salt = await bcrypt.genSalt(10);
                    user.password = await bcrypt.hash(user.password, salt);
                }
            },
        },
    }
);

-----------------------------------------------------------------------------------Publication
import db from '../config/database';
import type { User } from './User';
import type { Comment } from './Comment';
import {
    Model,
    DataTypes,
    BelongsToManyAddAssociationMixin,
    BelongsToManyGetAssociationsMixin,
    BelongsToManyRemoveAssociationMixin,
    HasManyGetAssociationsMixin,
} from 'sequelize';

// --- Publication Model Attributes ---
export interface PublicationAttributes {
    id: string;
    userId: string;
    content: string;
    imageUrl?: string;
    videoUrl?: string; // [NEW] For video content
    category?: string;
    likeCount: number;
    commentCount: number;
    createdAt?: Date;
    updatedAt?: Date;
}

// --- Publication Model Class ---
export class Publication extends Model<PublicationAttributes> implements PublicationAttributes {
    public id!: string;
    public userId!: string;
    public content!: string;
    public imageUrl?: string;
    public videoUrl?: string; // [NEW]
    public category?: string;
    public likeCount!: number;
    public commentCount!: number;
    public readonly createdAt!: Date;
    public readonly updatedAt!: Date;

    // Associations
    public getLikers!: BelongsToManyGetAssociationsMixin<User>;
    public addLiker!: BelongsToManyAddAssociationMixin<User, string>;
    public removeLiker!: BelongsToManyRemoveAssociationMixin<User, string>;
    public getComments!: HasManyGetAssociationsMixin<Comment>;
}

// --- Initialize Publication Model ---
Publication.init(
    {
        id: {
            type: DataTypes.UUID,
            defaultValue: DataTypes.UUIDV4,
            primaryKey: true,
        },
        userId: {
            type: DataTypes.UUID,
            allowNull: false,
            references: {
                model: 'users',
                key: 'id',
            },
        },
        content: {
            type: DataTypes.TEXT,
            allowNull: false,
        },
        imageUrl: {
            type: DataTypes.STRING,
            allowNull: true,
        },
        videoUrl: {
            type: DataTypes.STRING,
            allowNull: true,
        },
        category: {
            type: DataTypes.STRING,
            allowNull: true,
        },
        likeCount: {
            type: DataTypes.INTEGER,
            allowNull: false,
            defaultValue: 0
        },
        commentCount: {
            type: DataTypes.INTEGER,
            allowNull: false,
            defaultValue: 0
        }
    },
    {
        sequelize: db,
        modelName: 'Publication',
        tableName: 'publications',
    }
);

-----------------------------------------------------------------------------------Subscriptions
import db from '../config/database';

import { DataTypes, Model } from 'sequelize';

// --- Subscription Model Attributes (Join Table) ---
export interface SubscriptionAttributes {
    followerId: string;
    followingId: string;
}

// --- Subscription Model Class ---
export class Subscription extends Model<SubscriptionAttributes> implements SubscriptionAttributes {
    public followerId!: string;
    public followingId!: string;
}

// --- Initialize Subscription Model ---
Subscription.init(
    {
        followerId: {
            type: DataTypes.UUID,
            primaryKey: true,
            references: {
                model: 'users',
                key: 'id',
            },
        },
        followingId: {
            type: DataTypes.UUID,
            primaryKey: true,
            references: {
                model: 'users',
                key: 'id',
            },
        },
    },
    {
        sequelize: db,
        modelName: 'Subscription',
        tableName: 'subscriptions',
        timestamps: false, // No createdAt/updatedAt for a join table
    }
);


-----------------------------------------------------------------------------------LikedComment and LikedPublication
import db from '../config/database';
import { DataTypes, Model } from 'sequelize';

export interface LikedCommentAttributes {
    userId: string;
    commentId: string;
}

export class LikedComment extends Model<LikedCommentAttributes> implements LikedCommentAttributes {
    public userId!: string;
    public commentId!: string;
}

LikedComment.init(
    {
        userId: {
            type: DataTypes.UUID,
            primaryKey: true,
            references: {
                model: 'users',
                key: 'id',
            },
        },
        commentId: {
            type: DataTypes.UUID,
            primaryKey: true,
            references: {
                model: 'comments',
                key: 'id',
            },
        },
    },
    {
        sequelize: db,
        modelName: 'LikedComment',
        tableName: 'liked_comments',
        timestamps: false,
    }
);
import db from '../config/database';
import { DataTypes, Model } from 'sequelize';

export interface LikedPublicationAttributes {
    userId: string;
    publicationId: string;
}

export class LikedPublication extends Model<LikedPublicationAttributes> implements LikedPublicationAttributes {
    public userId!: string;
    public publicationId!: string;
}

LikedPublication.init(
    {
        userId: {
            type: DataTypes.UUID,
            primaryKey: true,
            references: {
                model: 'users',
                key: 'id',
            },
        },
        publicationId: {
            type: DataTypes.UUID,
            primaryKey: true,
            references: {
                model: 'publications',
                key: 'id',
            },
        },
    },
    {
        sequelize: db,
        modelName: 'LikedPublication',
        tableName: 'liked_publications',
        timestamps: false,
    }
);

-----------------------------------------------------------------------------------Gallery
import db from '../config/database';
import { Model, DataTypes, BelongsToGetAssociationMixin } from 'sequelize';
import type { User } from './User';

// --- Gallery Model Attributes ---
export interface GalleryAttributes {
    id: string;
    userId: string;
    prompt: string;
    imageUrl: string;
    generationType: string;
    createdAt?: Date;
    updatedAt?: Date;
}

// --- Gallery Model Class ---
export class Gallery extends Model<GalleryAttributes> implements GalleryAttributes {
    public id!: string;
    public userId!: string;
    public prompt!: string;
    public imageUrl!: string;
    public generationType!: string;

    // Timestamps
    public readonly createdAt!: Date;
    public readonly updatedAt!: Date;

    // Associations
    public getUser!: BelongsToGetAssociationMixin<User>;
}

// --- Initialize Gallery Model ---
Gallery.init(
    {
        id: {
            type: DataTypes.UUID,
            defaultValue: DataTypes.UUIDV4,
            primaryKey: true,
        },
        userId: {
            type: DataTypes.UUID,
            allowNull: false,
            references: {
                model: 'users',
                key: 'id',
            },
        },
        prompt: {
            type: DataTypes.TEXT,
            allowNull: false,
        },
        imageUrl: {
            type: DataTypes.STRING,
            allowNull: false,
        },
        generationType: {
            type: DataTypes.STRING,
            allowNull: false,
        },
    },
    {
        sequelize: db,
        modelName: 'Gallery',
        tableName: 'galleries',
    }
);

-----------------------------------------------------------------------------------Comments
import db from '../config/database';
import {
    Model,
    DataTypes,
    BelongsToGetAssociationMixin,
    HasManyGetAssociationsMixin,
    HasManyAddAssociationMixin,
    BelongsToManyGetAssociationsMixin,
    BelongsToManyAddAssociationMixin,
    BelongsToManyRemoveAssociationMixin
} from 'sequelize';
import type { User } from './User';
import type { Publication } from './Publication';

// --- Comment Model Attributes ---
export interface CommentAttributes {
    id: string;
    text: string;
    userId: string;
    publicationId: string;
    parentId?: string;
    likeCount: number;
    createdAt?: Date;
    updatedAt?: Date;
}

// --- Comment Model Class ---
export class Comment extends Model<CommentAttributes> implements CommentAttributes {
    public id!: string;
    public text!: string;
    public userId!: string;
    public publicationId!: string;
    public parentId?: string;
    public likeCount!: number;

    // Timestamps
    public readonly createdAt!: Date;
    public readonly updatedAt!: Date;

    // --- Sequelize Mixins for Associations ---
    public getAuthor!: BelongsToGetAssociationMixin<User>;
    public getPublication!: BelongsToGetAssociationMixin<Publication>;
    public getParent!: BelongsToGetAssociationMixin<Comment>;
    public getReplies!: HasManyGetAssociationsMixin<Comment>;
    public addReply!: HasManyAddAssociationMixin<Comment, string>;

    // For likes
    public getLikers!: BelongsToManyGetAssociationsMixin<User>;
    public addLiker!: BelongsToManyAddAssociationMixin<User, string>;
    public removeLiker!: BelongsToManyRemoveAssociationMixin<User, string>;
}

// --- Initialize Comment Model ---
Comment.init(
    {
        id: {
            type: DataTypes.UUID,
            defaultValue: DataTypes.UUIDV4,
            primaryKey: true,
        },
        text: {
            type: DataTypes.TEXT,
            allowNull: false,
        },
        userId: {
            type: DataTypes.UUID,
            allowNull: false,
            references: {
                model: 'users',
                key: 'id',
            },
        },
        publicationId: {
            type: DataTypes.UUID,
            allowNull: false,
            references: {
                model: 'publications',
                key: 'id',
            },
        },
        parentId: {
            type: DataTypes.UUID,
            allowNull: true,
            references: {
                model: 'comments', // Self-reference for replies
                key: 'id',
            },
        },
        likeCount: {
            type: DataTypes.INTEGER,
            allowNull: false,
            defaultValue: 0,
        },
    },
    {
        sequelize: db,
        modelName: 'Comment',
        tableName: 'comments',
    }
);

-----------------------------------------------------------------------------------associations
import { User } from './User';
import { Comment } from './Comment';
import { Gallery } from './Gallery';
import { Publication } from './Publication';
import { Subscription } from './Subscription';
import { LikedComment } from './LikedComment';
import { LikedPublication } from './LikedPublication';

export const setupAssociations = () => {
    // User -> Publication (One-to-Many)
    User.hasMany(Publication, {
        foreignKey: 'userId',
        as: 'publications',
        onDelete: 'CASCADE'
    });
    Publication.belongsTo(User, {
        foreignKey: 'userId',
        as: 'author',
    });

    // User <-> User (Many-to-Many through Subscription for followers/following)
    User.belongsToMany(User, {
        as: 'Followers',
        through: Subscription,
        foreignKey: 'followingId',
        otherKey: 'followerId',
    });
    User.belongsToMany(User, {
        as: 'Following',
        through: Subscription,
        foreignKey: 'followerId',
        otherKey: 'followingId',
    });

    // User <-> Publication (Many-to-Many through LikedPublication for likes)
    User.belongsToMany(Publication, {
        as: 'likedPublications',
        through: LikedPublication,
        foreignKey: 'userId',
        otherKey: 'publicationId',
    });
    Publication.belongsToMany(User, {
        as: 'likers',
        through: LikedPublication,
        foreignKey: 'publicationId',
        otherKey: 'userId',
    });

    // User -> Comment (One-to-Many)
    User.hasMany(Comment, {
        foreignKey: 'userId',
        as: 'comments',
        onDelete: 'CASCADE'
    });
    Comment.belongsTo(User, {
        foreignKey: 'userId',
        as: 'author',
    });

    // Publication -> Comment (One-to-Many)
    Publication.hasMany(Comment, {
        foreignKey: 'publicationId',
        as: 'comments',
        onDelete: 'CASCADE'
    });
    Comment.belongsTo(Publication, {
        foreignKey: 'publicationId',
        as: 'publication',
    });

    // Comment -> Comment (Self-referencing for replies)
    Comment.hasMany(Comment, {
        foreignKey: 'parentId',
        as: 'replies',
        onDelete: 'CASCADE'
    });
    Comment.belongsTo(Comment, {
        foreignKey: 'parentId',
        as: 'parent',
    });

    // User <-> Comment (Many-to-Many for likes on comments)
    User.belongsToMany(Comment, {
        as: 'likedComments',
        through: LikedComment,
        foreignKey: 'userId',
        otherKey: 'commentId',
    });
    Comment.belongsToMany(User, {
        as: 'likers',
        through: LikedComment,
        foreignKey: 'commentId',
        otherKey: 'userId',
    });

    // User -> Gallery (One-to-Many)
    User.hasMany(Gallery, {
        foreignKey: 'userId',
        as: 'galleryItems',
        onDelete: 'CASCADE'
    });
    Gallery.belongsTo(User, {
        foreignKey: 'userId',
        as: 'user',
    });

    console.log('Database associations have been set up.');
};

-----------------------------------------------------------------------------------controllers
-----------------------------------------------------------------------------------auth
import bcrypt from 'bcrypt';
import crypto from 'crypto';

import { Op } from 'sequelize';
import { User } from '../models/User';
import { Request, Response } from 'express';
import { generateToken } from '../services/authService';
import { sendVerificationEmail } from '../services/emailService';
import { handleForgotPassword } from '../services/passwordService';

// --- Step 1: Register Email and Send OTP ---
export const registerStep1 = async (req: Request, res: Response) => {
    try {
        const { email } = req.body;
        if (!email) {
            return res.status(400).json({ message: 'Email is required.' });
        }

        const existingUser = await User.findOne({ where: { email } });
        if (existingUser && existingUser.verified) {
            return res.status(400).json({ message: 'Email already in use.' });
        }

        const otp = crypto.randomInt(100000, 999999).toString();
        const otpExpires = new Date(Date.now() + 10 * 60 * 1000); // 10 minutes
        const hashedOtp = await bcrypt.hash(otp, 10);

        if (existingUser) {
            existingUser.otp = hashedOtp;
            existingUser.otpExpires = otpExpires;
            await existingUser.save();
        } else {
            await User.create({ email, otp: hashedOtp, otpExpires });
        }

        await sendVerificationEmail(email, otp);
        return res.status(200).json({ message: 'OTP sent to your email.' });

    } catch (error) {
        console.error('Register Step 1 Error:', error);
        return res.status(500).json({ message: 'Server error during registration step 1.' });
    }
};

// --- Step 2: Verify OTP ---
export const registerStep2 = async (req: Request, res: Response) => {
    try {
        const { email, otp } = req.body;
        if (!email || !otp) {
            return res.status(400).json({ message: 'Email and OTP are required.' });
        }

        const user = await User.findOne({ where: { email } });
        if (!user || !user.otp || !user.otpExpires) {
            return res.status(400).json({ message: 'Invalid request. Please try again.' });
        }

        if (new Date() > user.otpExpires) {
            return res.status(400).json({ message: 'OTP has expired.' });
        }

        const isMatch = await bcrypt.compare(otp, user.otp);
        if (!isMatch) {
            return res.status(400).json({ message: 'Invalid OTP.' });
        }

        user.verified = true;
        user.otp = undefined;
        user.otpExpires = undefined;
        await user.save();

        return res.status(200).json({ message: 'Email verified successfully.' });

    } catch (error) {
        console.error('Register Step 2 Error:', error);
        return res.status(500).json({ message: 'Server error during OTP verification.' });
    }
};

// --- Step 3: Complete Registration ---
export const registerStep3 = async (req: Request, res: Response) => {
    try {
        const { email, fullname, username, password } = req.body;
        if (!email || !fullname || !username || !password) {
            return res.status(400).json({ message: 'All fields are required.' });
        }

        const user = await User.findOne({ where: { email, verified: true } });
        if (!user) {
            return res.status(400).json({ message: 'Email not verified or user not found.' });
        }

        const existingUsername = await User.findOne({ where: { username } });
        if (existingUsername) {
            return res.status(400).json({ message: 'Username is already taken.' });
        }

        user.fullname = fullname;
        user.username = username;
        user.password = password; // Hashed by beforeUpdate hook
        await user.save();

        const token = generateToken(user.id);
        res.cookie('token', token, {
            httpOnly: true,
            secure: process.env.NODE_ENV === 'production',
            maxAge: 365 * 24 * 60 * 60 * 1000,
        });

        const { password: _, ...userResponse } = user.get({ plain: true });
        return res.status(201).json({ token, user: userResponse });

    } catch (error) {
        console.error('Register Step 3 Error:', error);
        return res.status(500).json({ message: 'Server error during final registration step.' });
    }
};

// --- Login User ---
export const login = async (req: Request, res: Response) => {
    try {
        const { usernameOrEmail, password } = req.body;

        const user = await User.findOne({
            where: {
                [Op.or]: [
                    { username: usernameOrEmail },
                    { email: usernameOrEmail },
                ],
            },
        });

        if (!user) {
            return res.status(400).json({ message: 'Invalid credentials' });
        }

        const isMatch = await user.comparePassword(password);
        if (!isMatch) {
            return res.status(400).json({ message: 'Invalid credentials' });
        }

        // Generate JWT token
        const token = generateToken(user.id);

        // Set cookie
        res.cookie('token', token, {
            httpOnly: true,
            secure: process.env.NODE_ENV === 'production',
            maxAge: 365 * 24 * 60 * 60 * 1000 // 365 days
        });

        // Exclude password from the response
        const { password: _, ...userResponse } = user.get({ plain: true });

        return res.json({
            token,
            user: userResponse
        });
    } catch (error) {
        console.error('Login error:', error);
        return res.status(500).json({ message: 'Server error during login' });
    }
};

// --- Logout User ---
export const logout = (req: Request, res: Response) => {
    res.clearCookie('token');
    return res.json({ message: 'Logged out successfully' });
};

// --- Get Current User ---
export const getMe = async (req: Request, res: Response) => {
    try {
        // req.user is attached by the auth middleware
        const user = req.user;

        if (!user) {
            return res.status(404).json({ message: 'User not found' });
        }

        // Exclude password from the response
        const { password, ...userResponse } = user.get({ plain: true });

        return res.json({
            user: userResponse
        });
    } catch (error) {
        console.error('Get current user error:', error);
        return res.status(500).json({ message: 'Server error' });
    }
};

// --- Forgot Password Controller ---
export const forgotPassword = async (req: Request, res: Response) => {
    try {
        const { email } = req.body;
        if (!email) {
            return res.status(400).json({ message: 'Email is required.' });
        }
        await handleForgotPassword(email);
        return res.status(200).json({ message: 'If a user with that email exists, a password reset link has been sent.' });

    } catch (error) {
        console.error('Forgot Password Error:', error);
        return res.status(500).json({ message: 'Server error during forgot password process.' });
    }
};

// --- Reset Password Controller ---
export const resetPassword = async (req: Request, res: Response) => {
    try {
        const { token } = req.params;
        const { password } = req.body;

        if (!password) {
            return res.status(400).json({ message: "Password is required." });
        }

        const users = await User.findAll({
            where: {
                passwordResetTokenExpires: { [Op.gt]: new Date() }
            }
        });

        let userToUpdate: User | null = null;
        for (const user of users) {
            if (user.passwordResetToken && await bcrypt.compare(token, user.passwordResetToken)) {
                userToUpdate = user;
                break;
            }
        }

        if (!userToUpdate) {
            return res.status(400).json({ message: 'Token is invalid or has expired.' });
        }

        userToUpdate.password = password; // Will be hashed by hook
        userToUpdate.passwordResetToken = undefined;
        userToUpdate.passwordResetTokenExpires = undefined;
        await userToUpdate.save();

        return res.status(200).json({ message: 'Password has been reset successfully.' });

    } catch (error) {
        console.error('Reset Password Error:', error);
        return res.status(500).json({ message: 'Server error during password reset.' });
    }
};

-----------------------------------------------------------------------------------comment
import db from '../config/database';

import { User } from '../models/User';
import { Comment } from '../models/Comment';
import { Request, Response } from 'express';
import { Publication } from '../models/Publication';
import { fetchReplies, handleUserAction } from '../lib/utils';

// --- Create a Comment ---
export const createComment = async (req: Request, res: Response) => {
    try {
        const { publicationId } = req.params;
        const { text } = req.body;

        const userId = req.user.id;
        const me = await User.findByPk(userId);

        if (!text) {
            return res.status(400).json({ message: 'Comment text cannot be empty.' });
        }

        const publication = await Publication.findByPk(publicationId);
        if (!publication) {
            return res.status(404).json({ message: 'Publication not found.' });
        }

        let comment;
        await db.transaction(async (t) => {
            comment = await Comment.create({
                userId,
                publicationId,
                text,
            }, { transaction: t });

            await publication.increment('commentCount', { transaction: t });
            await handleUserAction(me, 20);
        });

        res.status(201).json(comment);
    } catch (error) {
        console.error('Create comment error:', error);
        res.status(500).json({ message: 'Server error while creating comment.' });
    }
};


// --- Reply to a Comment ---
export const replyToComment = async (req: Request, res: Response) => {
    try {
        const { commentId } = req.params;
        const { text } = req.body;
        const userId = req.user.id;

        if (!text) {
            return res.status(400).json({ message: 'Reply text cannot be empty.' });
        }

        const parentComment = await Comment.findByPk(commentId);
        if (!parentComment) {
            return res.status(404).json({ message: 'Parent comment not found.' });
        }

        const publication = await Publication.findByPk(parentComment.publicationId);
        if (!publication) {
            return res.status(404).json({ message: 'Associated publication not found.' });
        }

        let reply: any;

        await db.transaction(async (t) => {
            reply = await Comment.create({
                userId,
                publicationId: parentComment.publicationId,
                text,
                parentId: commentId,
            }, { transaction: t });

            await publication.increment('commentCount', { transaction: t });
        });

        res.status(201).json(reply);

    } catch (error) {
        console.error('Reply to comment error:', error);
        res.status(500).json({ message: 'Server error while replying to comment.' });
    }
};

// --- Get Comments for a Publication ---
export const getCommentsForPublication = async (req: Request, res: Response) => {
    try {
        const { publicationId } = req.params;
        const topLevelComments = await Comment.findAll({
            where: { publicationId, parentId: null },
            include: [{ model: User, as: 'author', attributes: ['id', 'username', 'fullname', 'avatar'] }],
            order: [['createdAt', 'ASC']],
        });

        for (const comment of topLevelComments) {
            (comment as any).dataValues.replies = await fetchReplies(comment);
        }

        res.status(200).json(topLevelComments);
    } catch (error) {
        console.error('Get comments error:', error);
        res.status(500).json({ message: 'Server error while fetching comments.' });
    }
};

// --- Update a Comment ---
export const updateComment = async (req: Request, res: Response) => {
    try {
        const { commentId } = req.params;
        const { text } = req.body;
        const userId = req.user.id;

        const comment = await Comment.findByPk(commentId);
        if (!comment) {
            return res.status(404).json({ message: 'Comment not found.' });
        }

        if (comment.userId !== userId) {
            return res.status(403).json({ message: 'You are not authorized to edit this comment.' });
        }

        comment.text = text;
        await comment.save();

        res.status(200).json(comment);
    } catch (error) {
        console.error('Update comment error:', error);
        res.status(500).json({ message: 'Server error while updating comment.' });
    }
};

// --- Delete a Comment ---
export const deleteComment = async (req: Request, res: Response) => {
    try {
        const { commentId } = req.params;
        const userId = req.user.id;

        const comment = await Comment.findByPk(commentId);
        if (!comment) {
            return res.status(404).json({ message: 'Comment not found.' });
        }

        if (comment.userId !== userId) {
            return res.status(403).json({ message: 'You are not authorized to delete this comment.' });
        }

        const publication = await Publication.findByPk(comment.publicationId);

        await db.transaction(async (t) => {
            // This will also delete all replies due to ON DELETE CASCADE
            await comment.destroy({ transaction: t });

            // Decrement publication's comment count if it exists
            if (publication && publication.commentCount > 0) {
                // Count replies to be deleted as well
                const replyCount = await Comment.count({ where: { parentId: commentId }, transaction: t });
                const totalDecrement = 1 + replyCount;

                if (publication.commentCount - totalDecrement >= 0) {
                    await publication.decrement('commentCount', { by: totalDecrement, transaction: t });
                } else {
                    publication.commentCount = 0;
                    await publication.save({ transaction: t });
                }
            }
        });

        res.status(200).json({ message: 'Comment deleted successfully.' });
    } catch (error) {
        console.error('Delete comment error:', error);
        res.status(500).json({ message: 'Server error while deleting comment.' });
    }
};

// --- Like a Comment ---
export const likeComment = async (req: Request, res: Response) => {
    try {
        const { commentId } = req.params;
        const userId = req.user.id;

        const comment = await Comment.findByPk(commentId);
        if (!comment) {
            return res.status(404).json({ message: 'Comment not found.' });
        }

        const user = await User.findByPk(userId);
        if (!user) {
            return res.status(404).json({ message: 'User not found' });
        }

        await db.transaction(async (t) => {
            await user.addLikedComment(comment, { transaction: t });
            await comment.increment('likeCount', { transaction: t });
        });

        res.status(200).json({ message: 'Comment liked successfully.' });
    } catch (error) {
        console.error('Like comment error:', error);
        if (error.name === 'SequelizeUniqueConstraintError') {
            return res.status(409).json({ message: 'You have already liked this comment.' });
        }
        res.status(500).json({ message: 'Server error while liking comment.' });
    }
};

// --- Unlike a Comment ---
export const unlikeComment = async (req: Request, res: Response) => {
    try {
        const { commentId } = req.params;
        const userId = req.user.id;

        const comment = await Comment.findByPk(commentId);
        if (!comment) {
            return res.status(404).json({ message: 'Comment not found.' });
        }

        const user = await User.findByPk(userId);
        if (!user) {
            return res.status(404).json({ message: 'User not found' });
        }

        await db.transaction(async (t) => {
            const result = await user.removeLikedComment(comment, { transaction: t });
            if (result === null) {
                throw new Error("Not liked");
            }
            if (comment.likeCount > 0) {
                await comment.decrement('likeCount', { transaction: t });
            }
        });

        res.status(200).json({ message: 'Comment unliked successfully.' });
    } catch (error) {
        if (error.message === 'Not liked') {
            return res.status(404).json({ message: 'You have not liked this comment.' });
        }
        console.error('Unlike comment error:', error);
        res.status(500).json({ message: 'Server error while unliking comment.' });
    }
};

-----------------------------------------------------------------------------------gallery
import { Gallery } from '../models/Gallery';
import { Request, Response } from 'express';

// --- Get User's Private Gallery ---
export const getMyGallery = async (req: Request, res: Response) => {
    try {
        const userId = req.user.id;

        const galleryItems = await Gallery.findAll({
            where: { userId },
            order: [['createdAt', 'DESC']],
        });

        if (!galleryItems) {
            return res.status(200).json([]);
        }

        res.status(200).json(galleryItems);
    } catch (error) {
        console.error('Get gallery error:', error);
        res.status(500).json({ message: 'Server error while fetching gallery.' });
    }
};

-----------------------------------------------------------------------------------publication
import db from '../config/database';

import { Op } from 'sequelize';
import { User } from '../models/User';
import { Comment } from '../models/Comment';
import { Request, Response } from 'express';
import { Publication } from '../models/Publication';
import { Subscription } from '../models/Subscription';
import { LikedPublication } from '../models/LikedPublication';
import { fetchReplies, handleUserAction } from '../lib/utils';

// --- Get Single Publication by ID with full comment tree ---
export const getPublicationById = async (req: Request, res: Response) => {
    try {
        const { publicationId } = req.params;
        const userId = req.user.id;

        const publication = await Publication.findByPk(publicationId, {
            include: [
                {
                    model: User,
                    as: 'author',
                    attributes: ['id', 'username', 'fullname', 'avatar']
                }
            ],
        });

        if (!publication) {
            return res.status(404).json({ message: 'Publication not found' });
        }

        // Fetch comments separately with full hierarchy
        const topLevelComments = await Comment.findAll({
            where: { publicationId: publication.id, parentId: null },
            include: [{ model: User, as: 'author', attributes: ['id', 'username', 'fullname', 'avatar'] }],
            order: [['createdAt', 'ASC']],
        });

        for (const comment of topLevelComments) {
            (comment as any).dataValues.replies = await fetchReplies(comment);
        }

        const publicationJson = publication.toJSON();

        // Add isLiked and isFollowing info
        const isFollowing = await Subscription.findOne({ where: { followerId: userId, followingId: publication.userId } });
        const isLiked = await LikedPublication.findOne({ where: { userId, publicationId: publication.id } });

        const publicationWithExtras = {
            ...publicationJson,
            isFollowing: !!isFollowing,
            isLiked: !!isLiked
        };

        res.json(publicationWithExtras);
    } catch (error) {
        console.error('Get publication by ID error:', error);
        res.status(500).json({ message: 'Server error' });
    }
};

// --- The rest of the publication controller remains largely the same ---
const addExtraInfoToPublications = async (publications: Publication[], userId: string) => {
    if (publications.length === 0) return [];
    const authorIds = publications.map(p => p.userId);
    const publicationIds = publications.map(p => p.id);

    const following = await Subscription.findAll({
        where: { followerId: userId, followingId: { [Op.in]: authorIds } },
    });
    const followingIds = new Set(following.map(sub => sub.followingId));

    const liked = await LikedPublication.findAll({
        where: { userId, publicationId: { [Op.in]: publicationIds } },
    });
    const likedPublicationIds = new Set(liked.map(like => like.publicationId));

    return publications.map(p => {
        const publicationJson = p.toJSON();
        return {
            ...publicationJson,
            isFollowing: followingIds.has(p.userId),
            isLiked: likedPublicationIds.has(p.id),
        };
    });
};

export const createPublication = async (req: Request, res: Response) => {
    try {
        const { content } = req.body;
        const userId = req.user.id;
        let imageUrl: string | undefined;

        if (req.file) {
            imageUrl = `/publications/${req.file.filename}`;
        }

        if (!content && !imageUrl) {
            return res.status(400).json({ message: 'Publication must have content or an image.' });
        }


        const publication = await Publication.create({
            userId,
            content,
            imageUrl,
            category: "Not defined",
            likeCount: 0,
            commentCount: 0
        });

        res.status(201).json({ message: 'Publication created successfully', publication });
    } catch (error) {
        console.error('Create publication error:', error);
        res.status(500).json({ message: 'Server error during publication creation' });
    }
};

export const getAllPublications = async (req: Request, res: Response) => {
    try {
        const userId = req.user.id;
        const { sortBy, category } = req.query;

        let order: any = [['createdAt', 'DESC']];
        if (sortBy === 'mostLiked') {
            order = [['likeCount', 'DESC']];
        } else if (sortBy === 'mostCommented') {
            order = [['commentCount', 'DESC']];
        }

        let whereClause: any = {};
        if (category) {
            whereClause.category = category;
        }

        const publications = await Publication.findAll({
            where: whereClause,
            order: order,
            include: [{ model: User, as: 'author', attributes: ['id', 'username', 'fullname', 'avatar'] }]
        });

        const publicationsWithInfo = await addExtraInfoToPublications(publications, userId);

        res.json(publicationsWithInfo);
    } catch (error) {
        console.error('Get all publications error:', error);
        res.status(500).json({ message: 'Server error' });
    }
};

export const updatePublication = async (req: Request, res: Response) => {
    try {
        const { publicationId } = req.params;
        const { content } = req.body;
        const userId = req.user.id;

        const publication = await Publication.findByPk(publicationId);

        if (!publication) return res.status(404).json({ message: 'Publication not found' });
        if (publication.userId !== userId) return res.status(403).json({ message: 'You are not authorized to edit this publication' });

        publication.content = content || publication.content;
        await publication.save();

        res.json({ message: 'Publication updated successfully', publication });
    } catch (error) {
        console.error('Update publication error:', error);
        res.status(500).json({ message: 'Server error' });
    }
};

export const likePublication = async (req: Request, res: Response) => {
    try {
        const userId = req.user.id;
        const { publicationId } = req.params;

        const publication = await Publication.findByPk(publicationId);
        if (!publication) return res.status(404).json({ message: 'Publication not found' });

        const user = await User.findByPk(userId);
        if (!user) return res.status(404).json({ message: 'User not found' });

        await db.transaction(async (t) => {
            await LikedPublication.create({ userId, publicationId }, { transaction: t });
            await publication.increment('likeCount', { transaction: t });
            if (publication.category) {
                const currentInterests = user.interests || [];
                if (!currentInterests.includes(publication.category)) {
                    user.interests = [...currentInterests, publication.category];
                    await user.save({ transaction: t });
                    await handleUserAction(user, 10);
                }
            }
        });

        res.status(200).json({ message: 'Publication liked successfully' });
    } catch (error) {
        console.error('Like publication error:', error);
        if (error.name === 'SequelizeUniqueConstraintError') return res.status(409).json({ message: 'You have already liked this publication.' });
        res.status(500).json({ message: 'Server error' });
    }
};

export const unlikePublication = async (req: Request, res: Response) => {
    try {
        const userId = req.user.id;
        const { publicationId } = req.params;

        const publication = await Publication.findByPk(publicationId);
        if (!publication) return res.status(404).json({ message: 'Publication not found' });

        await db.transaction(async (t) => {
            const result = await LikedPublication.destroy({ where: { userId, publicationId }, transaction: t });
            if (result === 0) throw new Error("Not liked");
            if (publication.likeCount > 0) {
                await publication.decrement('likeCount', { transaction: t });
            }
        });

        res.status(200).json({ message: 'Publication unliked successfully' });
    } catch (error) {
        if (error.message === 'Not liked') return res.status(404).json({ message: 'You have not liked this publication.' });
        console.error('Unlike publication error:', error);
        res.status(500).json({ message: 'Server error' });
    }
};

export const getMyLikedPublications = async (req: Request, res: Response) => {
    try {
        const userId = req.user.id;
        const user = await User.findByPk(userId);

        if (!user) return res.status(404).json({ message: 'User not found' });
        const likedPublications = await user.getLikedPublications({
            include: [{ model: User, as: 'author', attributes: ['id', 'username', 'fullname', 'avatar'] }],
            order: [['createdAt', 'DESC']]
        });

        const publicationsWithInfo = await addExtraInfoToPublications(likedPublications, userId);

        res.json(publicationsWithInfo);
    } catch (error) {
        console.error('Get liked publications error:', error);
        res.status(500).json({ message: 'Server error' });
    }
};

-----------------------------------------------------------------------------------user
import fs from 'fs';
import path from 'path';

import { Op } from 'sequelize';
import { User } from '../models/User';
import { Request, Response } from 'express';
import { handleUserAction } from '../lib/utils';
import { Publication } from '../models/Publication';
import { Subscription } from '../models/Subscription';
import { LikedPublication } from '../models/LikedPublication';

// Helper function from publicationController - assuming it's exported or moved to a shared service
const addExtraInfoToPublications = async (publications: Publication[], userId: string) => {
    const authorIds = publications.map(p => p.userId);
    const publicationIds = publications.map(p => p.id);

    const following = await Subscription.findAll({
        where: { followerId: userId, followingId: { [Op.in]: authorIds } },
    });
    const followingIds = new Set(following.map(sub => sub.followingId));

    const liked = await LikedPublication.findAll({
        where: { userId: userId, publicationId: { [Op.in]: publicationIds } },
    });
    const likedPublicationIds = new Set(liked.map(like => like.publicationId));

    return publications.map(p => {
        const publicationJson = p.toJSON();
        return {
            ...publicationJson,
            isFollowing: followingIds.has(p.userId),
            isLiked: likedPublicationIds.has(p.id),
        };
    });
};

// Helper function to add isFollowing flag to a list of users
const addIsFollowingInfoToUsers = async (users: User[], currentUserId: string) => {
    const userIds = users.map(u => u.id);
    const subscriptions = await Subscription.findAll({
        where: {
            followerId: currentUserId,
            followingId: { [Op.in]: userIds }
        }
    });
    const followingIds = new Set(subscriptions.map(s => s.followingId));

    return users.map(user => {
        const userJson = user.toJSON();
        delete userJson.password; // ensure password is not returned
        return {
            ...userJson,
            isFollowing: followingIds.has(user.id)
        };
    });
};

// --- Get User Profile ---
export const getProfile = async (req: Request, res: Response) => {
    try {
        const { username } = req.params;
        const currentUser = req.user;

        const user = await User.findOne({
            where: { username },
            attributes: { exclude: ['password', 'email'] },
        });

        if (!user) {
            return res.status(404).json({ message: 'User not found' });
        }

        const publications = await user.getPublications({
            include: [{ model: User, as: 'author', attributes: ['id', 'username', 'fullname', 'avatar'] }],
            order: [['createdAt', 'DESC']]
        });
        const publicationsWithInfo = await addExtraInfoToPublications(publications, currentUser.id);

        const publicationsCount = publications.length;
        const followersCount = (await user.getFollowers()).length;
        const followingCount = (await user.getFollowing()).length;

        let isFollowing = false;
        if (currentUser && currentUser.id !== user.id) {
            const subscription = await Subscription.findOne({
                where: {
                    followerId: currentUser.id,
                    followingId: user.id
                }
            });
            isFollowing = !!subscription;
        } else if (currentUser && currentUser.id === user.id) {
            isFollowing = false; // You don't follow yourself
        }

        const userResponse = user.get({ plain: true });

        res.json({
            ...userResponse,
            publicationsCount,
            followersCount,
            followingCount,
            isFollowing,
            publications: publicationsWithInfo // [NEW] Return publications
        });
    } catch (error) {
        console.error('Get profile error:', error);
        res.status(500).json({ message: 'Server error' });
    }
};

// --- Get Current Authenticated User Profile ---
export const getMe = async (req: Request, res: Response) => {
    try {
        const userId = req.user.id;
        const user = await User.findByPk(userId, {
            attributes: { exclude: ['password'] }, // email can be included for self-profile
        });

        if (!user) {
            return res.status(404).json({ message: 'User not found' });
        }

        const publications = await user.getPublications({
            include: [{ model: User, as: 'author', attributes: ['id', 'username', 'fullname', 'avatar'] }],
            order: [['createdAt', 'DESC']]
        });
        const publicationsWithInfo = await addExtraInfoToPublications(publications, userId);

        const publicationsCount = publications.length;
        const followersCount = (await user.getFollowers()).length;
        const followingCount = (await user.getFollowing()).length;

        const userResponse = user.get({ plain: true });

        res.json({
            ...userResponse,
            publicationsCount,
            followersCount,
            followingCount,
            publications: publicationsWithInfo // [NEW] Return publications
        });
    } catch (error) {
        console.error('Get current user profile error:', error);
        res.status(500).json({ message: 'Server error' });
    }
};

// --- Get My Followers ---
export const getMyFollowers = async (req: Request, res: Response) => {
    try {
        const userId = req.user.id;

        const user = await User.findByPk(userId);
        if (!user) {
            return res.status(404).json({ message: 'User not found' });
        }

        const followers = await user.getFollowers({
            attributes: ['id', 'username', 'fullname', 'avatar']
        });

        const followersWithInfo = await addIsFollowingInfoToUsers(followers, userId);

        res.json(followersWithInfo);
    } catch (error) {
        console.error('Get my followers error:', error);
        res.status(500).json({ message: 'Server error' });
    }
};

// --- Get My Followings ---
export const getMyFollowings = async (req: Request, res: Response) => {
    try {
        const userId = req.user.id;

        const user = await User.findByPk(userId);
        if (!user) {
            return res.status(404).json({ message: 'User not found' });
        }

        const followings = await user.getFollowing({
            attributes: ['id', 'username', 'fullname', 'avatar']
        });

        const followingsWithInfo = await addIsFollowingInfoToUsers(followings, userId);

        res.json(followingsWithInfo);
    } catch (error) {
        console.error('Get my followings error:', error);
        res.status(500).json({ message: 'Server error' });
    }
};

// --- Update Current User's Profile ---
export const updateProfile = async (req: Request, res: Response) => {
    try {
        const { fullname, bio, interests } = req.body;
        const userId = req.user.id;

        const user = await User.findByPk(userId);
        if (!user) {
            return res.status(404).json({ message: 'User not found' });
        }

        user.fullname = fullname || user.fullname;
        user.bio = bio || user.bio;

        if (Array.isArray(interests)) {
            user.interests = interests;
        }

        await user.save();

        const { password, ...userResponse } = user.get({ plain: true });
        res.json({ message: 'Profile updated successfully', user: userResponse });

    } catch (error) {
        console.error('Update profile error:', error);
        res.status(500).json({ message: 'Server error' });
    }
};

// --- Update User Avatar ---
export const updateAvatar = async (req: Request, res: Response) => {
    try {
        const userId = req.user.id;
        const user = await User.findByPk(userId);

        if (!user) {
            return res.status(404).json({ message: 'User not found' });
        }

        if (user.avatar) {
            const oldAvatarPath = path.join(__dirname, '../../public', user.avatar);
            if (fs.existsSync(oldAvatarPath)) {
                fs.unlinkSync(oldAvatarPath);
            }
        }

        if (!req.file) {
            return res.status(400).json({ message: 'No file uploaded.' });
        }

        const avatarUrlPath = `/users/avatars/${req.file.filename}`;
        user.avatar = avatarUrlPath;
        await user.save();

        const { password, ...userResponse } = user.get({ plain: true });
        res.json({ message: 'Avatar updated successfully', user: userResponse });

    } catch (error) {
        console.error('Update avatar error:', error);
        res.status(500).json({ message: 'Server error' });
    }
};

// --- Search for Users ---
export const searchUsers = async (req: Request, res: Response) => {
    try {
        const { query } = req.query;
        const currentUserId = req.user.id;

        if (!query || typeof query !== 'string') {
            return res.status(400).json({ message: 'Search query is required' });
        }

        const users = await User.findAll({
            where: {
                [Op.or]: [
                    { username: { [Op.iLike]: `%${query}%` } },
                    { fullname: { [Op.iLike]: `%${query}%` } }
                ],
                id: { [Op.ne]: currentUserId } // Exclude self from search results
            },
            attributes: ['id', 'username', 'fullname', 'bio', 'avatar'],
            limit: 10
        });

        const usersWithFollowingInfo = await addIsFollowingInfoToUsers(users, currentUserId);

        res.json(usersWithFollowingInfo);
    } catch (error) {
        console.error('Search users error:', error);
        res.status(500).json({ message: 'Server error' });
    }
};

// --- Subscribe (Follow) a User ---
export const subscribe = async (req: Request, res: Response) => {
    try {
        const followerId = req.user.id;
        const { userId: followingId } = req.params;

        if (followerId === followingId) {
            return res.status(400).json({ message: "You cannot follow yourself." });
        }

        const userToFollow = await User.findByPk(followingId);
        if (!userToFollow) {
            return res.status(404).json({ message: 'User to follow not found' });
        }

        const me = await User.findByPk(followerId);
        await me.addFollowing(userToFollow);
        await handleUserAction(me, 30);

        res.status(200).json({ message: `Successfully followed ${userToFollow.username}` });
    } catch (error) {
        console.error('Subscribe error:', error);
        if (error.name === 'SequelizeUniqueConstraintError') {
            return res.status(409).json({ message: 'You are already following this user.' });
        }
        res.status(500).json({ message: 'Server error' });
    }
};

// --- Unsubscribe (Unfollow) a User ---
export const unsubscribe = async (req: Request, res: Response) => {
    try {
        const followerId = req.user.id;
        const { userId: followingId } = req.params;

        const userToUnfollow = await User.findByPk(followingId);
        if (!userToUnfollow) {
            return res.status(404).json({ message: 'User to unfollow not found' });
        }

        const me = await User.findByPk(followerId);
        const result = await me.removeFollowing(userToUnfollow);

        if (result === null) {
            return res.status(404).json({ message: "You are not following this user." });
        }

        res.status(200).json({ message: `Successfully unfollowed ${userToUnfollow.username}` });
    } catch (error) {
        console.error('Unsubscribe error:', error);
        res.status(500).json({ message: 'Server error' });
    }
};

// --- Get User's Followers ---
export const getFollowers = async (req: Request, res: Response) => {
    try {
        const { username } = req.params;
        const currentUserId = req.user.id;

        const user = await User.findOne({ where: { username } });
        if (!user) {
            return res.status(404).json({ message: 'User not found' });
        }

        const followers = await user.getFollowers({
            attributes: ['id', 'username', 'fullname', 'avatar']
        });

        const followersWithInfo = await addIsFollowingInfoToUsers(followers, currentUserId);

        res.json(followersWithInfo);
    } catch (error) {
        console.error('Get followers error:', error);
        res.status(500).json({ message: 'Server error' });
    }
}

// --- Get User's Following ---
export const getFollowing = async (req: Request, res: Response) => {
    try {
        const { username } = req.params;
        const currentUserId = req.user.id;

        const user = await User.findOne({ where: { username } });
        if (!user) {
            return res.status(404).json({ message: 'User not found' });
        }

        const following = await user.getFollowing({
            attributes: ['id', 'username', 'fullname', 'avatar']
        });

        const followingWithInfo = await addIsFollowingInfoToUsers(following, currentUserId);

        res.json(followingWithInfo);
    } catch (error) {
        console.error('Get following error:', error);
        res.status(500).json({ message: 'Server error' });
    }
}
-----------------------------------------------------------------------------------higgsfield
import { Request, Response } from 'express';
import { generateVideo, getVideo, downloadVideo } from '../services/higgsfieldService';
import { Publication } from '../models/Publication';
import { Gallery } from '../models/Gallery';
import fs from 'fs';

const sleep = (ms: number) => new Promise(resolve => setTimeout(resolve, ms));

export const generateAndProcessVideo = async (req: Request, res: Response) => {
    const {
        publish,
        enhance_prompt,
        seed,
        width,
        height,
        motion_id,
        prompt
    } = req.body;

    const userId = req.user.id;
    const files = req.files as Express.Multer.File[];

    if (!files || files.length === 0) {
        return res.status(400).json({ message: 'At least one image is required.' });
    }

    try {
        // --- THIS IS THE CHANGE ---
        // Construct the public URLs for the uploaded files
        const imageUrls = files.map(file => {
            // The URL path will be /ai_uploads/filename.ext
            const filePath = `/ai_uploads/${file.filename}`;
            return `${process.env.BACKEND_URL}${filePath}`;
        });

        const apiPayload = {
            motion_id,
            prompt,
            enhance_prompt: enhance_prompt === 'true',
            seed: parseInt(seed, 10),
            width: parseInt(width, 10),
            height: parseInt(height, 10)
        };

        // Pass the payload and the array of public image URLs to the service
        const generationResponse = await generateVideo(apiPayload, imageUrls);
        // --- END OF CHANGE ---

        // After successfully sending the request, delete the temporary public files
        files.forEach(file => fs.unlinkSync(file.path));

        const taskId = generationResponse.id;

        if (!taskId) {
            return res.status(500).json({ message: 'Failed to get a task ID from Higgsfield.' });
        }

        // The rest of the function remains the same...
        let videoResult;
        let attempts = 0;
        const maxAttempts = 60;

        while (attempts < maxAttempts) {
            await sleep(5000);
            const statusResponse = await getVideo(taskId);

            if (statusResponse.jobs && statusResponse.jobs[0]) {
                const job = statusResponse.jobs[0];
                if (job.status === 'completed') {
                    videoResult = job.result.url;
                    break;
                } else if (job.status === 'failed') {
                    return res.status(500).json({ message: 'Video generation failed.' });
                }
            }
            attempts++;
        }

        if (!videoResult) {
            return res.status(500).json({ message: 'Video generation timed out.' });
        }

        const downloadedVideoPath = await downloadVideo(videoResult);

        if (publish === 'true') {
            const publication = await Publication.create({
                userId,
                content: prompt || 'Generated Video',
                videoUrl: downloadedVideoPath,
            });
            res.status(201).json({ message: 'Video published successfully.', publication });
        } else {
            const galleryItem = await Gallery.create({
                userId,
                prompt: prompt || 'Generated Video',
                imageUrl: downloadedVideoPath,
                generationType: 'video',
            });
            res.status(201).json({ message: 'Video saved to your private gallery.', galleryItem });
        }
    } catch (error) {
        console.error('Higgsfield video generation process error:', error);
        res.status(500).json({ message: 'An error occurred during the video generation process.' });
    }
};

-----------------------------------------------------------------------------------routes
-----------------------------------------------------------------------------------auth
import express from 'express';
import * as authController from '../controllers/authController';

import { auth } from '../middleware/auth';
import { asyncHandler } from '../lib/utils';

const router = express.Router();

// Multi-step registration routes
router.post('/register-step-1', asyncHandler(authController.registerStep1));
router.post('/register-step-2', asyncHandler(authController.registerStep2));
router.post('/register-step-3', asyncHandler(authController.registerStep3));

// Login user
router.post('/login', asyncHandler(authController.login));

// Logout user
router.post('/logout', asyncHandler(authController.logout));

// Get current authenticated user
router.get('/me', auth, asyncHandler(authController.getMe));

// Password Management
router.post('/forgot-password', asyncHandler(authController.forgotPassword));
router.post('/reset-password/:token', asyncHandler(authController.resetPassword));


export default router;

-----------------------------------------------------------------------------------comment
import express from "express";
import * as commentController from '../controllers/commentController';

import { auth } from '../middleware/auth';
import { asyncHandler } from "../lib/utils";

const router = express.Router();

// Create a comment
router.post('/:publicationId/comments', auth, asyncHandler(commentController.createComment));

// Get all comments for a publication (can be used for a separate comments page/section)
router.get('/:publicationId/comments', auth, asyncHandler(commentController.getCommentsForPublication));

// Reply to an existing comment
router.post('/:commentId/reply', auth, asyncHandler(commentController.replyToComment));

// Update a comment
router.put('/:commentId', auth, asyncHandler(commentController.updateComment));

// Delete a comment
router.delete('/:commentId', auth, asyncHandler(commentController.deleteComment));

// Like a comment
router.post('/:commentId/like', auth, asyncHandler(commentController.likeComment));

// Unlike a comment
router.delete('/:commentId/unlike', auth, asyncHandler(commentController.unlikeComment));

export default router;

-----------------------------------------------------------------------------------publication
import express from "express";
import * as publicationController from '../controllers/publicationController';

import { auth } from '../middleware/auth';
import { asyncHandler } from "../lib/utils";
import { uploadPublicationImage } from '../middleware/upload';

const router = express.Router();

// Get all publications (feed)
router.get('/', auth, asyncHandler(publicationController.getAllPublications));

// Get current user's liked publications
router.get('/me/liked', auth, asyncHandler(publicationController.getMyLikedPublications));

// Create a new publication
router.post('/', auth, uploadPublicationImage, asyncHandler(publicationController.createPublication));

// Get a single publication by ID
router.get('/:publicationId', auth, asyncHandler(publicationController.getPublicationById));

// Update a publication
router.put('/:publicationId', auth, asyncHandler(publicationController.updatePublication));

// Like a publication
router.post('/:publicationId/like', auth, asyncHandler(publicationController.likePublication));

// Unlike a publication
router.delete('/:publicationId/unlike', auth, asyncHandler(publicationController.unlikePublication));

export default router;

-----------------------------------------------------------------------------------user
import express from 'express';
import * as userController from '../controllers/userController';

import { auth } from '../middleware/auth';
import { asyncHandler } from '../lib/utils';
import { uploadAvatar } from '../middleware/upload';

const router = express.Router();

// Search for users
router.get('/search/users', auth, asyncHandler(userController.searchUsers));

// Get your own detailed profile
router.get('/me/profile', auth, asyncHandler(userController.getMe));

// Get your own followings
router.get('/me/profile/followers', auth, asyncHandler(userController.getMyFollowers))

// Get your own followers
router.get('/me/profile/following', auth, asyncHandler(userController.getMyFollowings))

// Update your profile
router.put('/me/profile', auth, asyncHandler(userController.updateProfile));

// Update your avatar
router.put('/me/avatar', auth, uploadAvatar, asyncHandler(userController.updateAvatar));

// Get a user's profile by username (must be after /me and /search routes)
router.get('/:username', auth, asyncHandler(userController.getProfile));

// Get a user's followers
router.get('/:username/followers', auth, asyncHandler(userController.getFollowers));

// Get a user's following
router.get('/:username/following', auth, asyncHandler(userController.getFollowing));

// Subscribe to (follow) a user by their ID
router.post('/:userId/subscribe', auth, asyncHandler(userController.subscribe));

// Unsubscribe from (unfollow) a user by their ID
router.delete('/:userId/unsubscribe', auth, asyncHandler(userController.unsubscribe));

export default router;

-----------------------------------------------------------------------------------higgsfield
import express from 'express';
import * as higgsfieldController from '../controllers/higgsfieldController';
import { auth } from '../middleware/auth';
import { asyncHandler } from '../lib/utils';
import { uploadPrivateImages } from '../middleware/upload';

const router = express.Router();

router.post(
    '/generate',
    auth,
    uploadPrivateImages,
    asyncHandler(higgsfieldController.generateAndProcessVideo)
);

export default router;

-----------------------------------------------------------------------------------index
import cors from 'cors';
import path from 'path';
import dotenv from 'dotenv';
import express from 'express';
import cookieParser from 'cookie-parser';

import db from './config/database';

// Import model associations setup
import { setupAssociations } from './models/associations';

// Import routes
import authRoutes from './routes/auth';
import userRoutes from './routes/user';
import galleryRoutes from './routes/gallery';
import commentRoutes from './routes/comment';
import higgsfieldRoutes from './routes/higgsfield';
import publicationRoutes from './routes/publication';

dotenv.config()

// Initialize express app
const app = express();
const PORT = process.env.PORT || 5000;

// Middleware
app.use(
  cors({
    origin: process.env.FRONTEND_URL,
    credentials: true,
  })
);

app.use(express.json());
app.use(express.urlencoded({ extended: true }));
app.use(cookieParser());

// Serve static files from the 'public' directory
app.use(express.static(path.join(__dirname, '../public')));

// Routes
app.use('/api/auth', authRoutes);
app.use('/api/users', userRoutes);
app.use('/api/gallery', galleryRoutes);
app.use('/api/comments', commentRoutes);
app.use('/api/higgsfield', higgsfieldRoutes);
app.use('/api/publications', publicationRoutes);

// Initialize database and start server
const startServer = async () => {
  try {
    // Setup model associations
    setupAssociations();

    await db.sync({ alter: true });
    console.log('Database synchronized');

    // Start the server
    app.listen(PORT, () => {
      console.log(`Server running on port ${PORT}`);
    });
  } catch (error) {
    console.error('Failed to start server:', error);
  }
};

startServer();